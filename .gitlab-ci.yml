########################
# Global configuration #
########################
stages:
  - fmt
  - plan
  - apply        # terraform apply (manual)
  - build        # build Docker image
  - deploy       # pull image on EC2 (manual)

variables:
  TF_VER: "1.8.5"
  TF_WORKDIR: "."
  AWS_REGION: "eu-west-3"

############################
# Shared template for TF jobs
############################
.default_tf:
  image: hashicorp/terraform:${TF_VER}
  entrypoint: [""]                     # <— run shell, not terraform
  before_script:
    - terraform --version
    - |
      terraform -chdir=${TF_WORKDIR} init \
        -input=false \
        -backend-config="bucket=${TF_STATE_BUCKET}" \
        -backend-config="dynamodb_table=${TF_STATE_DDB_TABLE}" \
        -backend-config="region=${AWS_REGION}"

################
# 1. Formatting
################
fmt:
  extends: .default_tf
  stage: fmt
  script:
    - terraform -chdir=${TF_WORKDIR} fmt -check -recursive

###########
# 2. Plan
###########
plan:
  extends: .default_tf
  stage: plan
  script:
    - terraform -chdir=${TF_WORKDIR} validate
    - terraform -chdir=${TF_WORKDIR} plan -out=tfplan -input=false
  artifacts:
    paths: [ "${TF_WORKDIR}/tfplan" ]
    expire_in: 1 week

############
# 3. Apply
############
apply:
  extends: .default_tf
  stage: apply
  script:
    - terraform -chdir=${TF_WORKDIR} apply -auto-approve tfplan
  dependencies:
    - plan               # <─ one item, still a YAML list
  when: manual
  only:
    - main
  environment:
    name: dev


########################
# 4. Build Docker image
########################
docker_build:
  stage: build
  image: docker:25.0
  services: [ docker:dind ]
  variables:
    DOCKER_DRIVER: overlay2
  before_script:
    - apk add --no-cache python3 py3-pip
    - pip install awscli
    - aws ecr get-login-password --region ${AWS_REGION} | \
      docker login --username AWS --password-stdin $(echo ${ECR_REPO_URI} | cut -d/ -f1)
  script:
    - docker build -t ${ECR_REPO_URI}:${CI_COMMIT_SHORT_SHA} ./docker
    - docker push ${ECR_REPO_URI}:${CI_COMMIT_SHORT_SHA}
  only:
    - main

#####################
# 5. Deploy on EC2
#####################
ssh_deploy:
  stage: deploy
  image: alpine:3.20
  needs: [ docker_build ]
  before_script:
    - apk add --no-cache openssh aws-cli
    - mkdir -p ~/.ssh
    - echo "$SSH_KEY" > ~/.ssh/id_rsa
    - chmod 600 ~/.ssh/id_rsa
    # fetch carrier-grade IP of the WLZ instance tagged Name=wlz-app-dev-fe
    - |
      WLZ_IP=$(aws ec2 describe-instances \
        --filters "Name=tag:Name,Values=wlz-app-dev-fe" \
        --query 'Reservations[0].Instances[0].PublicIpAddress' \
        --output text)
      echo "WLZ_IP=$WLZ_IP" >> "$CI_ENVIRONMENT_FILE"
  script: |
    TAG=${CI_COMMIT_SHORT_SHA}
    ssh -o StrictHostKeyChecking=no ec2-user@${WLZ_IP} <<'SSH'
      set -e
      sudo docker login -u AWS -p $(aws ecr get-login-password --region ${AWS_REGION})
      sudo docker pull ${ECR_REPO_URI}:${TAG}
      # stop old container (if any)
      OLD=$(sudo docker ps -q)
      [ -n "$OLD" ] && sudo docker stop "$OLD"
      # run new container
      sudo docker run -d --rm -p 80:3000 ${ECR_REPO_URI}:${TAG}
  
  SSH
when: manual
only:
    - main
